{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n\n      _events.push(value);\n\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n\n      this._trimBufferThenGetEvents();\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject);\n\nexport { ReplaySubject };\n\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();","map":{"version":3,"mappings":";AAAA,OAAO,KAAEA,OAAT,MAAwB,OAAxB;AAEA,SAASC,OAAT,QAAsB,WAAtB;AAEA,SAASC,KAAT,QAAqB,mBAArB;AACA,SAASC,YAAT,QAA4B,gBAA5B;AACA,SAASC,mBAAT,QAAkC,uBAAlC;AACA,SAASC,uBAAT,QAAoC,gCAApC;AAQA;;IAAsCC,uCAAUC,MAAV,EAAU;AAM9CP,mCAAyDO,MAAzD;;WAAYD,sCAAqBE,WAAO;AAC5B;AADZC,gBAGE,2BAHF;AAEoB;;AAPZ,kBAAO,KAA8B,MAArC,EAAqC;AAGrCC;AAMN;;AACA,aAAK,SAAW,KAAX,CAAc,IAAd,KAA2B,IAAhC;;AAEAC,SAAI,UAAJ,GAAcH,SAAd;SACE,WAAK;SACL,uBAAiB;SAClB;SAAM;;QACLE,UAAS,KAAGE,MAAK,oBAAe;AACjCD;;AACF,WAEO;AACFA,WAAK,CAACE,IAAN,GAAMF,KAAW,eAAjB;;;WAEFA;;;eAIE,WAAQG,yBAAQ;SACjB;AACF;;AACDC,mBAAMC,KAAN;;AACD;AAEOD;AACD;;;UAEH,WAAKF,gBAAwBG;;;eAE/B,WAAMC,iBAAK,UAAOD,KAAP,EAAO;AACnB;AAGD,6CAAWE,OAAX,IAAoCF,KAApC;;AAEQ;AACN;;AACAT,UAAM,UAAN,CAAkBM,IAAlB,CAAuBM,IAAvB,CAAuB,IAAvB,EAAiCH,KAAjC;;;eAEI,WAA2BI;AAE/B,QAAIC,mBAAa,2BAAjB;;QACEN,OAAM,GAAIM,2BAA0BN,OAA1B,GAA0B;;QACrCP;WAAM,GAAIO,OAAK;QACdO;;QACD;YAAM;WAEL,sBAAmB,aAAnB,EAAsC;AACvCA;AAED,KAHE,MAIA;AACD;AAEGA,yBAAmBC,mBAAnB,CAAqB,IAArB,EAAqBC,UAArB;;;mBAEA;gBACD;AACF;;6BAAM;AACL,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,GAAJ,IAAW,CAACF,UAAU,CAACG,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AAClDD,kBAAU,CAACX,IAAX,CAAiCE,OAAO,CAACU,CAAD,CAAxC;AACD;AACF,WAEG;AACF,gBAAU,GAAC,CAAX,EAAgBA,CAAC,MAAD,IAAM,WAAa,OAAnC,EAAmCA,GAAnC,EAAmC;AACpCD;AAAM;;;QAEN;AAEDA,gBAAO,MAAP,CAAoB,gBAApB;AACD,WAED;AACEA,gBAAa,SAAb;AACD;;AAEO;;;eAEA,WAAcN,UAAK,YAAY;AACrC,WAAM,mBAAmBhB,KAAnB,EAAmB0B,GAAnB,EAAN;;;eAGM,WAAcC,2BAAe;AACnC,QAAID,WAAWV,OAAX,EAAJ;;AAKA,mBAAO,GAAW,KAAGY,WAArB;QACEC,WAAW,QAAQA;eACjB,GAAM;mBACP;QACDC,WAAW,GAAG;;WACfA;AAEG,gBAAWjB,OAAG,aAAH,CAAgBkB,IAA3B,GAA2BF,WAA3B,EAA2B;AAC7B;AACD;;AAEGC,iBAAW;;;QAEdE;AAEDF,iBAAe,mDAAf;AACD;;AAEH,sBAAC,CAAD,EAAC;AAAAjB;;;AAED;AACE;;SAAmBT;CAxHiB;;SAyHnCA;;IACH6B,2BAAC;AAHD,WAGCA,WAHD,CAGCF,IAHD,EAGCjB,KAHD,EAGC;;;;;;CAAA","names":["tslib_1","Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","ReplaySubject","_super","scheduler","bufferSize","windowTime","_this","Number","next","nextInfiniteTimeWindow","_events","value","nextTimeWindow","_getNow","call","_subscribe","_infiniteTimeWindow","subscription","SubjectSubscription","subscriber","i","len","closed","now","_trimBufferThenGetEvents","_bufferSize","_windowTime","spliceCount","time","eventsCount","ReplayEvent"],"sources":["../../src/internal/ReplaySubject.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}